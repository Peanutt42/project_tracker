use project_tracker_core::Database;
use project_tracker_server::{
	load_database_from_file, messure_cpu_usage_avg_thread, ConnectedClient, CpuUsageAverage,
	DEFAULT_PASSWORD,
};
use std::collections::HashSet;
use std::fs::{read_to_string, OpenOptions};
use std::path::PathBuf;
use std::process::exit;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::info;
use tracing::level_filters::LevelFilter;
use tracing::warn;
use tracing_subscriber::layer::SubscriberExt;
use tracing_subscriber::Layer;
use warp::{path, reply::html, serve, Filter};

#[macro_use]
mod utils;

mod get_admin_infos;
use get_admin_infos::get_admin_infos_route;

mod load_database;
use load_database::load_database_route;

mod ws;
use ws::ws_route;

mod native_ws;
use native_ws::native_ws_route;

// get generated by 'build.rs'
const SELF_SIGNED_KEY_PEM: &[u8] = include_bytes!("self_signed_certificates/key.pem");
const SELF_SIGNED_CERT_PEM: &[u8] = include_bytes!("self_signed_certificates/cert.pem");

#[tokio::main]
async fn main() {
	let mut args = std::env::args();

	let server_data_directory_str = args.nth(1).unwrap_or_else(|| {
		eprintln!("usage: project_tracker_server [SERVER_DATA_DIRECTORY]");
		exit(1);
	});

	let server_data_directory = PathBuf::from(server_data_directory_str);

	if !server_data_directory.exists() {
		std::fs::create_dir_all(&server_data_directory)
			.expect("failed to create the supplied 'server_data_directory'");
	}

	let database_filepath = server_data_directory.join("database.project_tracker");
	let password_filepath = server_data_directory.join("password.txt");

	let password = if password_filepath.exists() {
		read_to_string(&password_filepath)
			.unwrap_or_else(|e| {
				eprintln!("failed to read password file!\nset password using the 'scripts/set_server_password_linux.sh' script\n{}, error: {e}", password_filepath.display());
				exit(1);
			})
	} else {
		eprintln!(
			"no password is set, using default password: 1234\nset it using the 'scripts/set_server_password_linux.sh' script\nor create a plaintext password.txt with the password inside the 'SERVER_DATA_DIRECTORY'!"
		);
		DEFAULT_PASSWORD.to_string()
	};

	let stdout_layer = tracing_subscriber::fmt::layer()
		.with_writer(std::io::stdout)
		.with_filter(LevelFilter::INFO);
	let log_filepath = server_data_directory.join("project_tracker_server.log");
	let log_file = OpenOptions::new()
		.append(true)
		.create(true)
		.open(&log_filepath)
		.expect("failed to open log file");
	let file_layer = tracing_subscriber::fmt::layer()
		.with_writer(log_file)
		.with_ansi(false)
		.with_filter(LevelFilter::INFO);
	tracing::subscriber::set_global_default(
		tracing_subscriber::registry()
			.with(stdout_layer)
			.with(file_layer),
	)
	.unwrap();

	let database = if database_filepath.exists() {
		load_database_from_file(database_filepath.clone()).unwrap_or_else(|| {
			eprintln!("failed to load database from file!");
			exit(1);
		})
	} else {
		eprintln!("no previous database found -> creating a empty database!");
		Database::default()
	};
	let shared_database = Arc::new(RwLock::new(database));

	let cpu_usage_avg = Arc::new(CpuUsageAverage::new());
	let cpu_usage_avg_clone = cpu_usage_avg.clone();
	tokio::spawn(messure_cpu_usage_avg_thread(cpu_usage_avg_clone));

	let connected_clients = Arc::new(RwLock::new(HashSet::<ConnectedClient>::new()));

	let (modified_sender, modified_receiver) = tokio::sync::broadcast::channel(10);

	let opt_custom_cert_pem_filepath = server_data_directory.join("cert.pem");
	let opt_custom_key_pem_filepath = server_data_directory.join("key.pem");
	let custom_cert_pem = tokio::fs::read(opt_custom_cert_pem_filepath).await.ok();
	let custom_key_pem = tokio::fs::read(opt_custom_key_pem_filepath).await.ok();
	let custom_cert_and_key_pem = match (custom_cert_pem, custom_key_pem) {
		(Some(_), None) => {
			warn!("only the custom cert.pem file is present, no key.pem found --> ignoring custom certificate!");
			None
		}
		(None, Some(_)) => {
			warn!("only the custom key.pem file is present, no cert.pem found --> ignoring custom certificate!");
			None
		}
		(None, None) => None,
		(Some(cert_pem), Some(key_pem)) => Some((cert_pem, key_pem)),
	};

	let index_html_route = path::end()
		.or(path("index.html"))
		.map(|_| html(include_str!("web_server/index.html")));

	let routes = index_html_route
		.or(css_route!("style.css"))
		.or(js_route!("script.js"))
		.or(js_route!("service-worker.js"))
		.or(json_route!("manifest.json"))
		.or(index_html_route!("login"))
		.or(js_route!("login/script.js"))
		.or(css_route!("login/style.css"))
		.or(index_html_route!("admin"))
		.or(js_route!("admin/script.js"))
		.or(css_route!("admin/style.css"))
		.or(ico_route!("static/favicon.ico"))
		.or(png_route!("static/icon_180x180.png"))
		.or(png_route!("static/apple-touch-icon.png"))
		.or(svg_route!("static/caret-down-fill.svg"))
		.or(svg_route!("static/caret-right-fill.svg"))
		.or(svg_route!("static/bar-chart-fill.svg"))
		.or(svg_route!("static/house-fill.svg"))
		.or(svg_route!("static/globe.svg"))
		.or(svg_route!("static/window.svg"))
		.or(svg_route!("static/wifi-off.svg"))
		.or(svg_route!("static/cpu.svg"))
		.or(svg_route!("static/hourglass-split.svg"))
		.or(svg_route!("static/memory.svg"))
		.or(svg_route!("static/thermometer-half.svg"))
		.or(svg_route!("static/file-earmark-text.svg"))
		.or(load_database_route(
			password.clone(),
			shared_database.clone(),
		))
		.or(get_admin_infos_route(
			password.clone(),
			connected_clients.clone(),
			cpu_usage_avg.clone(),
			log_filepath.clone(),
		))
		.or(ws_route(
			database_filepath.clone(),
			shared_database.clone(),
			modified_sender.clone(),
			modified_receiver.resubscribe(),
			connected_clients.clone(),
			password.clone(),
		))
		.or(native_ws_route(
			database_filepath.clone(),
			log_filepath.clone(),
			shared_database,
			modified_sender,
			modified_receiver,
			connected_clients,
			password,
			cpu_usage_avg,
		));

	let mut server = serve(routes).tls();

	match custom_cert_and_key_pem {
		Some((cert_pem, key_pem)) => {
			server = server.cert(cert_pem);
			server = server.key(key_pem);
		}
		None => {
			server = server.cert(SELF_SIGNED_CERT_PEM);
			server = server.key(SELF_SIGNED_KEY_PEM);
		}
	}

	let (https_addr, https_warp) = server.bind_ephemeral(([0, 0, 0, 0], 443));

	info!("https server listening on {https_addr}");

	https_warp.await;
}
