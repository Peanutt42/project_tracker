use futures_util::{SinkExt, StreamExt};
use project_tracker_core::Database;
use project_tracker_server::{AdminInfos, ConnectedClient, CpuUsageAverage, ModifiedEvent};
use serde::{Deserialize, Serialize};
use std::{collections::HashSet, net::SocketAddr, path::PathBuf, sync::Arc};
use tokio::sync::{broadcast::Receiver, RwLock};
use tracing::{error, info};
use warp::{
	body,
	http::StatusCode,
	path,
	path::end,
	post, reply,
	reply::{html, with_header, with_status, Reply, Response},
	serve, ws,
	ws::{Message, WebSocket, Ws},
	Filter,
};

// get generated by 'build.rs'
const SELF_SIGNED_KEY_PEM: &[u8] = include_bytes!("self_signed_certificates/key.pem");
const SELF_SIGNED_CERT_PEM: &[u8] = include_bytes!("self_signed_certificates/cert.pem");

const FAVICON_ICO: &[u8] = include_bytes!("static/favicon.ico");
const ICON_180X180_PNG: &[u8] = include_bytes!("static/icon_180x180.png");
const CARET_DOWN_SVG: &str = include_str!("static/caret-down-fill.svg");
const CARET_RIGHT_SVG: &str = include_str!("static/caret-right-fill.svg");
const BAR_CHART_SVG: &str = include_str!("static/bar-chart-fill.svg");
const HOUSE_CHART_SVG: &str = include_str!("static/house-fill.svg");
const GLOBE_SVG: &str = include_str!("static/globe.svg");
const WINDOW_SVG: &str = include_str!("static/window.svg");
const CPU_SVG: &str = include_str!("static/cpu.svg");
const HOURGLASS_SVG: &str = include_str!("static/hourglass-split.svg");
const MEMORY_SVG: &str = include_str!("static/memory.svg");
const THERMOMETER_HALF_SVG: &str = include_str!("static/thermometer-half.svg");
const FILE_TEXT_SVG: &str = include_str!("static/file-earmark-text.svg");

const INDEX_HTML: &str = include_str!("static/index.html");
const STYLE_CSS: &str = include_str!("static/style.css");
const SCRIPT_JS: &str = include_str!("static/script.js");
const SERVICE_WORKER_JS: &str = include_str!("static/service-worker.js");
const MANIFEST_JSON: &str = include_str!("static/manifest.json");

const LOGIN_INDEX_HTML: &str = include_str!("static/login/index.html");
const LOGIN_STYLE_CSS: &str = include_str!("static/login/style.css");
const LOGIN_SCRIPT_JS: &str = include_str!("static/login/script.js");

const ADMIN_INDEX_HTML: &str = include_str!("static/admin/index.html");
const ADMIN_STYLE_CSS: &str = include_str!("static/admin/style.css");
const ADMIN_SCRIPT_JS: &str = include_str!("static/admin/script.js");

pub async fn run_web_server(
	password: String,
	modified_receiver: Receiver<ModifiedEvent>,
	shared_database: Arc<RwLock<Database>>,
	connected_clients: Arc<RwLock<HashSet<ConnectedClient>>>,
	cpu_usage_avg: Arc<CpuUsageAverage>,
	log_filepath: PathBuf,
	custom_cert_and_key_pem: Option<(Vec<u8>, Vec<u8>)>,
) {
	let password_clone = password.clone();

	let shared_database_clone = shared_database.clone();

	let get_database_route = path("load_database")
		.and(post())
		.and(body::json())
		.and(warp::any().map(move || password_clone.clone()))
		.and(warp::any().map(move || shared_database_clone.clone()))
		.then(load_database);

	let password_clone = password.clone();

	let connected_clients_clone = connected_clients.clone();
	let connected_clients_clone = warp::any().map(move || connected_clients_clone.clone());

	let cpu_usage_avg_clone = cpu_usage_avg.clone();
	let cpu_usage_avg_clone = warp::any().map(move || cpu_usage_avg_clone.clone());

	let admin_infos_route = path("admin_infos")
		.and(post())
		.and(body::json())
		.and(warp::any().map(move || password_clone.clone()))
		.and(connected_clients_clone)
		.and(cpu_usage_avg_clone)
		.and(warp::any().map(move || log_filepath.clone()))
		.then(get_admin_infos);

	let modified_receiver = Arc::new(RwLock::new(modified_receiver));
	let modified_receiver = warp::any().map(move || modified_receiver.clone());

	let password_clone = password.clone();
	let password_clone = warp::any().map(move || password_clone.clone());

	let connected_clients_clone = connected_clients.clone();
	let connected_clients_clone = warp::any().map(move || connected_clients_clone.clone());

	let modified_ws_route = path("modified")
		.and(ws())
		.and(warp::addr::remote())
		.and(modified_receiver)
		.and(connected_clients_clone)
		.and(password_clone)
		.then(
			move |ws: Ws,
			      client_addr: Option<SocketAddr>,
			      modified_receiver: Arc<RwLock<Receiver<ModifiedEvent>>>,
			      connected_clients: Arc<RwLock<HashSet<ConnectedClient>>>,
			      password: String| {
				async move {
					let modified_receiver = modified_receiver.read().await.resubscribe();

					ws.on_upgrade(move |socket| {
						on_upgrade_modified_ws(
							socket,
							password,
							client_addr,
							modified_receiver,
							connected_clients,
						)
					})
				}
			},
		);

	let static_path = path("static");

	let favicon_route = static_path
		.and(path("favicon.ico"))
		.map(|| with_header(FAVICON_ICO, "Content-Type", "image/x-icon"));

	let icon_180x180_png_route = static_path
		.and(path("icon_180x180.png"))
		.map(|| with_header(ICON_180X180_PNG, "Content-Type", "image/png"));

	let caret_down_svg_route = static_path
		.and(path("caret-down-fill.svg"))
		.map(|| with_header(CARET_DOWN_SVG, "Content-Type", "image/svg+xml"));

	let caret_right_svg_route = static_path
		.and(path("caret-right-fill.svg"))
		.map(|| with_header(CARET_RIGHT_SVG, "Content-Type", "image/svg+xml"));

	let bar_chart_svg_route = static_path
		.and(path("bar-chart-fill.svg"))
		.map(|| with_header(BAR_CHART_SVG, "Content-Type", "image/svg+xml"));

	let house_svg_route = static_path
		.and(path("house-fill.svg"))
		.map(|| with_header(HOUSE_CHART_SVG, "Content-Type", "image/svg+xml"));

	let globe_svg_route = static_path
		.and(path("globe.svg"))
		.map(|| with_header(GLOBE_SVG, "Content-Type", "image/svg+xml"));

	let window_svg_route = static_path
		.and(path("window.svg"))
		.map(|| with_header(WINDOW_SVG, "Content-Type", "image/svg+xml"));

	let cpu_svg_route = static_path
		.and(path("cpu.svg"))
		.map(|| with_header(CPU_SVG, "Content-Type", "image/svg+xml"));

	let hourglass_svg_route = static_path
		.and(path("hourglass-split.svg"))
		.map(|| with_header(HOURGLASS_SVG, "Content-Type", "image/svg+xml"));

	let memory_svg_route = static_path
		.and(path("memory.svg"))
		.map(|| with_header(MEMORY_SVG, "Content-Type", "image/svg+xml"));

	let thermometer_svg_route = static_path
		.and(path("thermometer-half.svg"))
		.map(|| with_header(THERMOMETER_HALF_SVG, "Content-Type", "image/svg+xml"));

	let file_text_svg_route = static_path
		.and(path("file-earmark-text.svg"))
		.map(|| with_header(FILE_TEXT_SVG, "Content-Type", "image/svg+xml"));

	let asset_routes = favicon_route
		.or(icon_180x180_png_route)
		.or(caret_down_svg_route)
		.or(caret_right_svg_route)
		.or(bar_chart_svg_route)
		.or(house_svg_route)
		.or(globe_svg_route)
		.or(window_svg_route)
		.or(cpu_svg_route)
		.or(hourglass_svg_route)
		.or(memory_svg_route)
		.or(thermometer_svg_route)
		.or(file_text_svg_route);

	let index_route = end().map(|| html(INDEX_HTML));

	let style_route = static_path
		.and(path("style.css"))
		.map(|| with_header(STYLE_CSS, "Content-Type", "text/css"));

	let script_route = static_path
		.and(path("script.js"))
		.map(|| with_header(SCRIPT_JS, "Content-Type", "application/javascript"));

	let service_worker_route = static_path
		.and(path("service-worker.js"))
		.map(|| with_header(SERVICE_WORKER_JS, "Content-Type", "application/javascript"));

	let manifest_route = static_path
		.and(path("manifest.json"))
		.map(|| with_header(MANIFEST_JSON, "Content-Type", "application/json"));

	let main_routes = index_route
		.or(style_route)
		.or(script_route)
		.or(service_worker_route)
		.or(manifest_route);

	let login_path = static_path.and(path("login"));

	let login_html_route = path("login").and(end()).map(|| html(LOGIN_INDEX_HTML));

	let login_index_route = login_path.and(end()).map(|| html(LOGIN_INDEX_HTML));

	let login_style_route = login_path
		.and(path("style.css"))
		.map(|| with_header(LOGIN_STYLE_CSS, "Content-Type", "text/css"));

	let login_script_route = login_path
		.and(path("script.js"))
		.map(|| with_header(LOGIN_SCRIPT_JS, "Content-Type", "application/javascript"));

	let login_routes = login_html_route
		.or(login_index_route)
		.or(login_script_route)
		.or(login_style_route);

	let admin_path = static_path.and(path("admin"));

	let admin_html_route = path("admin").and(end()).map(|| html(ADMIN_INDEX_HTML));

	let admin_index_route = admin_path.and(end()).map(|| html(ADMIN_INDEX_HTML));

	let admin_style_route = admin_path
		.and(path("style.css"))
		.map(|| with_header(ADMIN_STYLE_CSS, "Content-Type", "text/css"));

	let admin_script_route = admin_path
		.and(path("script.js"))
		.map(|| with_header(ADMIN_SCRIPT_JS, "Content-Type", "application/javascript"));

	let admin_routes = admin_infos_route
		.or(admin_html_route)
		.or(admin_index_route)
		.or(admin_script_route)
		.or(admin_style_route);

	let routes = main_routes
		.or(login_routes)
		.or(admin_routes)
		.or(asset_routes)
		.or(get_database_route)
		.or(modified_ws_route);

	let mut server = serve(routes).tls();

	match custom_cert_and_key_pem {
		Some((cert_pem, key_pem)) => {
			server = server.cert(cert_pem);
			server = server.key(key_pem);
		}
		None => {
			server = server.cert(SELF_SIGNED_CERT_PEM);
			server = server.key(SELF_SIGNED_KEY_PEM);
		}
	}

	let (https_addr, https_warp) = server.bind_ephemeral(([0, 0, 0, 0], 443));

	info!("https server listening on {https_addr}");

	https_warp.await;
}

async fn load_database(
	body: serde_json::Value,
	password: String,
	shared_database: Arc<RwLock<Database>>,
) -> Response {
	if body.get("password") == Some(&serde_json::Value::String(password)) {
		info!("sending database as json");
		reply::json(shared_database.read().await.serialized()).into_response()
	} else {
		info!("invalid password providied, refusing access!");
		with_status(html("Unauthorized".to_string()), StatusCode::UNAUTHORIZED).into_response()
	}
}

async fn get_admin_infos(
	body: serde_json::Value,
	password: String,
	connected_clients: Arc<RwLock<HashSet<ConnectedClient>>>,
	cpu_usage_avg: Arc<CpuUsageAverage>,
	log_filepath: PathBuf,
) -> Response {
	if body.get("password") == Some(&serde_json::Value::String(password)) {
		info!("sending admin infos");
		reply::json(&AdminInfos::generate(
			connected_clients.read().await.clone(),
			cpu_usage_avg.as_ref(),
			&log_filepath,
		))
		.into_response()
	} else {
		info!("invalid password, refusing admin infos!");
		with_status(html("Unauthorized".to_string()), StatusCode::UNAUTHORIZED).into_response()
	}
}

async fn on_upgrade_modified_ws(
	mut ws: WebSocket,
	password: String,
	client_addr: Option<SocketAddr>,
	modified_receiver: Receiver<ModifiedEvent>,
	connected_clients: Arc<RwLock<HashSet<ConnectedClient>>>,
) {
	#[derive(Deserialize)]
	struct AuthenticateJson {
		password: String,
	}

	#[derive(Serialize)]
	struct AuthenticationResponse {
		successfull: bool,
	}

	// wait until client sends the correct password
	loop {
		if let Some(Ok(message)) = ws.next().await {
			if let Ok(msg_text) = message.to_str() {
				if let Ok(json_msg) = serde_json::from_str::<AuthenticateJson>(msg_text) {
					let successfull = json_msg.password == password;
					let _ = ws
						.send(Message::text(
							serde_json::to_string(&AuthenticationResponse { successfull }).unwrap(),
						))
						.await;
					if successfull {
						break;
					} else {
						info!("invalid password, refusing modified ws access");
					}
				}
			}
		}
	}

	let connected_client = client_addr.map(ConnectedClient::Web);

	if let Some(connected_client) = connected_client {
		connected_clients.write().await.insert(connected_client);
	}

	handle_modified_ws(ws, modified_receiver).await;

	if let Some(connected_client) = connected_client {
		connected_clients.write().await.remove(&connected_client);
	}
}

async fn handle_modified_ws(ws: WebSocket, mut modified_receiver: Receiver<ModifiedEvent>) {
	let (mut write_ws, mut read_ws) = ws.split();

	info!("modified ws client connected");

	loop {
		tokio::select! {
			modified_event_result = modified_receiver.recv() => {
				match modified_event_result {
					Ok(modified_event) => {
						match modified_event.modified_database.to_json() {
							Some(database_json) => {
								info!("sending database modified event in ws");
								if let Err(e) = write_ws.send(Message::text(database_json)).await {
									error!("failed to send modified event: {e}");
									return;
								}
							},
							None => error!("failed to serialize database in order to send to ws clients"),
						}
					},
					Err(e) => {
						error!("failed to receive further database modified events: {e}");
						return;
					},
				}
			},
			message = read_ws.next() => {
				if matches!(message, None | Some(Err(_))) {
					info!("modified ws connection closed");
					let _ = write_ws.close().await;
					return;
				}
			},
		};
	}
}
